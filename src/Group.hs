{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Group where

import Data.List (genericLength, elem, nub)
import Data.Proxy
import Data.Tree (Tree, unfoldTree)
import GHC.Prim
import GHC.TypeLits

-- | Group
-- where the following holds for all x, y, z :: g
-- @
-- operation (operation x y) z == operation x (operation y z)
-- operation identity x == operation x identity == x
-- operation x (inverse x) == operation (inverse x) x == identity
-- @
class (Eq g) => Group g where
  identity :: g
  operation :: g -> g -> g
  inverse :: g -> g

-- | Repeated application of the group operation
-- where @exponentiate a (-n)@ is interpreted as @exponentiate (inverse a) n@
exponentiate :: (Group g) => g -> Integer -> g
exponentiate a n
  | n == 0    = identity
  | n < 0     = exponentiate (inverse a) (-n)
  | otherwise = operation a (exponentiate a (n - 1))

-- | Cyclic subgroup generated an element
-- where the element may be of finite or infinite order
generateCyclic :: (Group g) => g -> [g]
generateCyclic x = identity : xs
  where
    xs = takeWhile ((/=) identity) $ fmap (exponentiate x) [1 .. ]

-- | Order of the cyclic subgroup generated by an element
-- will not terminate if the element is of infinite order
order :: (Group g) => g -> Integer
order x = genericLength $ generateCyclic x

-- | Generating set
generate :: (Group g) => [g] -> Tree (g, [g])
generate gs = unfoldTree f (identity, [])
  where
    gs' = nub gs
    f (x, p)
      | elem x p  = ((x, x : p), [])
      | otherwise = ((x, x : p), fmap (\ge -> (operation x ge, x : p)) gs')

-- | Abelian Group
-- where the following holds for all x, y :: g
-- @operation x y = operation y x@
class (Group g) => AbelianGroup g

-- | CountableGroup
-- where the elements of the group are enumerable and where it is assumed that
-- @minBound = identity@
class (Group g, Enum g) => CountableGroup g

elements :: (CountableGroup g) => [g]
elements = enumFrom identity

-- | FiniteGroup
-- where the group has a finite number of elements
class (CountableGroup g, Bounded g) => FiniteGroup g

cayleyTable :: (FiniteGroup g) => [(g, g, g)]
cayleyTable = concat $ fmap (\x -> fmap (\y -> (x, y, operation x y)) xs) xs
  where
    xs = enumFromTo minBound maxBound





-- | Examples of Groups

-- | (Z, +) Integers with addition
instance Group Integer where
  identity = 0
  operation = (+)
  inverse x = (- x)

instance AbelianGroup Integer
instance CountableGroup Integer

-- | (Zn, +) Integers with addition modulo n
newtype Z (n :: Nat)
  = Z Integer

instance (KnownNat n) => Show (Z n) where
  -- show (Z i) = "Z/" ++ show (natVal (Proxy :: Proxy n)) ++ " " ++ show i
  show (Z i) = show i

instance (KnownNat n) => Eq (Z n) where
  (==) (Z i) (Z j) = i == j

instance (KnownNat n) => Enum (Z n) where
  toEnum i = (Z (toInteger i))
  fromEnum (Z i) = fromIntegral i

instance (KnownNat n) => Bounded (Z n) where
  minBound = (Z 0)
  maxBound = (Z (natVal (Proxy :: Proxy n) - 1))

instance (KnownNat n) => Group (Z n) where
  identity = Z 0
  operation (Z i) (Z j) = Z (mod (i + j) (natVal (Proxy :: Proxy n)))
  inverse (Z i) = (Z ((natVal (Proxy :: Proxy n)) - i))

instance (KnownNat n) => AbelianGroup (Z n)
instance (KnownNat n) => CountableGroup (Z n)
instance (KnownNat n) => FiniteGroup (Z n)
